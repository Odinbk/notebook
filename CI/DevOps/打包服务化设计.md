# 打包任务服务化设计

## 

### 服务端

服务端框架，打包流程高度标准化，在游戏后端不引入新的技术栈，新工具的前提下可以很容易的实现成服务。
服务端打包过程中会生成要写入到配置中心的版本信息，其中包含客户端的版本，各类包的名称以及文件存储的路径。 所以存在对客户端打包的成功状态的依赖，是需要考虑的一个因素。

流程可以描述为:

1. 构建代码逻辑包。
  1. 从ResourceCenter下载CI资源， 解压缩。
  2. 处理各模块依赖管理文件中(举例Java项目的Pom文件。)描述的第三方依赖。
  3. 依赖体积优化，公用部分版本相同的第三方依赖。
  4. 根据运维或者发行方约定的包格式，创建压缩包。
2. 生成要注册到配置中心的配置文件。
3. 把1， 2步骤生成的产出打包成tar.gz包。
4. 把3步骤生成的tar.gz包上传到文件存储服务。

### 客户端

客户端打包流程总的来说可以描述为：

1. 遍历所有的升级序列，根据打包配置，生成完整包，更新包，等打包任务，添加到任务队列中。
2. 启动若干Worker，并发执行打包任务。

具体每种包构建流程如下

#### 完整包 (install_package)

1. 下载CI产出资源。
2. 生成完整包中的game.conf配置文件。
3. 将资源放入底包中，生成平台对应的完整包，重签名，上传到文件存储服务。

#### 更新包 (upgrade_package)

1. 根据WallE传递的升级包路径，对比资源变更情况，下载变更的资源，打包。
2. 上传包到文件存储服务。

#### 迷你包 (mini_package), 扩展包 (extension_package)

和完整包构建流程基本一致。

## 服务需求

* 服务参考当前的打包流程，抽象打包阶段。
* 任务还是通过jenkins来调度，每个阶段串行执行。
* 每个阶段都支持enter和exit，enter和exit都支持事件委托链，用来支持潜在的流程扩展需求。
* 流程中任意一个步骤，包括委托链中的事件失败，都必须中断整个打包流程，并提供详细的debug信息，每个步骤失败需要有钉钉通知。
* 打包阶段执行的若干类操作，需要抽象为Task任务，在合适的场景需要并发，以缩短打包时间。
* 前后端打包过程应该解耦，通过Redis或者其他方式完成进程间通信。
* 每个阶段都要具备可插拔替换的能力。


## 服务设计

* 定义抽象类Step
```python
@abstract
class Step():

    def exec():
        raise NotImplementError()
```

```python
class BuildBinary(Step):

    def exec():
        

```