# 在Java项目中尝试Unit Testing的总结

## 静态代码检查

静态代码检查包括两方面内容：

1. 代码规范， 主要面向安全编码规则, 意在避免潜在bug的发生。 例如： 变量命名， 类型使用， 未使用的变量，重复定义等。
2. 代码风格，更关注代码的格式，意在统一团队编码风格，增加代码可读性和降低维护成本。 例如： 代码缩进， JavaDoc检查等.

Java生态中有比较多的静态代码检查工具可以选择，工具选择主要基于以下考虑:

1. 工具被广泛使用， 有活跃的社区维护。
2. 同时支持Linux和Windows平台。
3. 可以根据项目需求灵活自定义检查规则， 添加和删除检查项目。
4. 有成熟的Eclipse和Intelij Idea插件

经过调研，pmd和codestyle两款工具比较符合以上条件.

* **[PMD](https://pmd.github.io/)** 目前只使用了官方的bestpractice规则，后续可以根据项目需求扩展或者自定义规则。

  ```bash
  > $ pmd-bin-6.6.0/bin/run.sh pmd -l java -R category/java/bestpractices.xml -dir {code base}
  ```

* **[CodeStyle](https://google.github.io/styleguide/javaguide.html)** 关于代码风格检查，CodeStyle支持Sun和Google的两套规则。但是Sun的规则已经多年没人维护，所以我们选择了Google。

  ```bash
  > $ java -jar checkstyle-8.12-all.jar -c /google_checks.xml {code base}
  ```

为了方便使用， 这两款工具已经集成到了git hook中。 当commit代码时自动触发， 有规则不通过则代码不能提交， 需要现行修复。

## 测试框架和Mock框架

Java生态中常用的测试框架一般是原生的JUnit和开源的TestNG. 就工具而言TestNG要远胜出JUnit，而且为了以后扩展测试类型， 例如：功能测试， 集成测试， UI自动化， 我们希望所有种类的测试可以在一套测试框架上维护。 而JUnit只支持单元测试。

单元测试要求测试尽可能排除外部依赖干扰，所以在编写单元测试时会频繁的使用Mock来隔离外部依赖。选择一款功能完备， 使用方便的Mock框架尤为重要. PowerMock集成了Mockito和Easymock的功能，在此之上支持Mock私有，静态，和保护方法. 此外PowerMock有较好的文档和社区支持，遇到问题容易在网上找到解决办法。

DK项目组的张旭军已经对这两款框架做了非常多的调研，在项目中也有很多使用经验。关于任何细节可以在[DK Server Test](https://git.youle.game/dk/dk-server-group/dk_server/wikis/dk-server-test)找到答案.

基于以上的考虑， 我们选择[TestNG](https://testng.org/doc/index.html) 和[PowerMock](https://github.com/powermock/powermock)的组合. 这意味着：

1. 今后所有的测试都应该在TestNG和PowerMock上开发
2. 对于各个组已经基于JUnit开发的测试用例，将不再维护.

## 自己的代码自己测 (慢即是快)

毫无疑问，编写单元测试将带来额外的工作量。开发者和策划往往会担心项目进度会受到影响。所以在游戏行业的一般情况是开发者写完代码后简单地和前端接口集成测试，剩下的工作都丢给QA同学。且不说QA手工测试的粒度只能验证主要路径，没有单元测试保护的代码在后续的需求变更和bug修复活动中几乎不可避免的会出现问题。修复一个bug经常会引入更多的bug，项目组渐渐陷入没完没了的bug当中。

单元测试在第一次写完测试通过以后就失去了找bug的意义，但是它可以持续的起到对代码的保护作用。需求变化或者代码需要重构的时候让开发者有自信局部的修改不会破坏整体的功能。而且单元测试也是项目做持续集成，持续发布的基础。短期内的额外工作量带来的后续持续的收益，从长远来看并不会拖慢反而会加快项目的进度。

但是也并不是说测试用例越多越好，100%的测试覆盖率看起来诱人，实际上想达到比较高的测试覆盖率都是要花费非常大的代价。而且测试用例在某种程度上会阻碍应对需求的变化 --每当需求变化时想到成百上千行的测试用例需要被删掉，心里总会抗拒去做出改变.

那么测试到底做还是不做。当然要做，但是要做得聪明.

* 对底层的模块，不容易发生变化的模块尽量覆盖足够多的单元测试. 例如：操作存储，网络的模块，各种Utility。
* 预期会有需求变化的业务层代码覆盖主要路径，覆盖Happy Path即可。
* 暴露给外部可见的public方法需要覆盖测试；逻辑处理的私有和受保护方法覆盖测试。起包装作用的方法比如setter， getter不需要测试覆盖。
* Bug修复一定要为其添加相应的测试用例，避免修复的bug在将来的代码变化中回归。

## 不运行的测试用例没有任何价值

成百上千的测试用例只有在运行的时候才能发挥它的价值。测试写了不跑还不如不写。测试需要在一致的环境下运行，避免在开发机上可以通过，但是在持续集成的环境下不能通过。在Docker的帮助下，可以在极短的时间内准备就绪测试环境。

1. 要支持快速触发一次测试，例如通过gitlab向Jenkins发送一条命令。
2. 开发机和持续集成环境保持一直。这点非常难做到，所以请看3，4。
3. 在持续集成的环境下执行全测试集合的测试。
4. 持续集成环境提供足够的信息和方便的渠道获取信息，方便开发者修复失败的测试。

测试执行的时间必须在合理的范围之内。我的经验是5分钟是上限，小于2分钟是比较好的情况。测试执行的慢可以分为两种情况：

1. 测试集合太大，运行的总时间变长。这种情况可以通过添加机器，并行执行来解决。
2. 单个测试执行时间太久。这种情况一般是测试用用例调用到了外部依赖，例如磁盘读写，网络IO等。可以通过Mock外部依赖解决。

测试用例一定要稳定，幂等。不稳定的测试浪费机器资源不说，也浪费开发者的时间，影响工作心情。不稳定的测试一般有以下原因：

1. 测试用例调用到了外部依赖. 外部依赖由于不可控往往会发生不稳定的情况。例如网络的抖动，磁盘读写异常等。这种情况可以通过Mock外部依赖解决。
2. 测试用例间有顺序依赖关系。例如测试B需要测试A先执行，设置某变量的值才能正确执行。TestNG和Unit甚至提供了特殊注解来支持这种情况。但是实际写测试时一定要禁止这种情况出现，因为这种机制非常容易被滥用，导致依赖链出现。而测试用例是会随着需求的变化做调整的，删除一条长链条中的几步是非常有可能的。 而没有人会愿意花时间了解他们的依赖关系。
3. 测试用例不是幂等。幂等的测试用例表示无论该测试被执行多少次，执行结果总是一样的。假如一个测试用例每次对一个全局变量的值做+1操作，而在它执行完成之后并没重置这个全局变量的值。那么在失败重试的情况下就会产生不稳定的情况。
4. 测试用例中使用了状态敏感的变量， 例如datetime.now(). 你会发现测试总是在下午的某个时间失败，而其他时间是正常的。

## 最后

以上的总结有一部分需要在项目组推广Unit Testing的时候反复实践和改进, 例如单元测试的最佳实践; 还有一部分需要技术支撑组提供基础设施的支持，例如持续集成的环境和Gitlab，Jenkins的插件支持。最理想的情况是开发组和技术支撑组并行推进，在较短时间内做到测试有地方运行，环境时时都有任务在跑。