# 开发环境管理

游戏项目组在开发期会申请若干开发环境用来满足：后端日常开发测试，和客户端/策划联调，QA本地测试等需求。 当前存在以下问题：

1. 开发机数量不够用。在项目忙的时候存在开发机竞争的情况。
2. 开发机的搭建，服务的部署和操作需要后端配合完成，占用后端时间。

## 需求

* 新创建的环境需要支持服务注册，服务发现。注册过程不需要人为参与，介入，完全自动化。
* 最小化环境：可以支持服务单独部署即可，尽量避免资源浪费。
* 专用环境：服务于特定，专一的目的。 避免多人共享导致环境不稳定, 不可用。
* 快速环境创建初始化：从开始创建，到初始化完成不应超过15分钟。
* 环境中部署的代码版本可以通过工具一键更新。
* 环境中运行的服务可以通过工具控制运行状态。
* 环境需要有监控和告警。

## 概要设计

### 环境宿主

#### Prons

目前公司有OpenStack私有云和K8s集群。
K8s的etcd组件可以承担服务注册，服务发现的功能。通过K8s CRD定制资源实现自定义类型的资源发现， K8s对CRD提供API，不需要自己开发API。
容器可以更好的满足环境快速搭建，快速变更。 容器的制作也可以由项目组自主完成，减少运维的参与和对业务系统的深度了解。

#### Cons

数据持久化
多组件环境编排

### 场景

#### 创建新环境

1. 为环境命名
2. 选择环境上要部署的代码/服务版本。（环境可能由多个服务组成）
3. 代理服务根据用户输入，生成K8s环境编排文件。
4. 代理服务执行部署过程，初始化环境。
5. 服务信息注册到etcd，用来描述环境中服务拓补关系。
6. 为各pod添加监控，告警。

#### 更新环境代码版本

1. 选择要更新的代码版本
2. 代理服务执行Dockerfile编译，构建出的镜像推送到harbor缓存。
3. 代理服务更新环境编排，将新容器版本在K8s中更新。

#### 更新环境


#### 回收销毁环境

## 详细设计

工具的核心逻辑是：

1. 根据用户在Web上的操作，生成环境描述文件。例如集群名称，包含哪些服务，服务之间的关系如何等信息。
2. Python模块根据环境描述文件生成K8s可以消费的集群编排文件。
3. 调用K8s REST API，将集群编排应用在K8s集群中，完成对集群的变更。

### 操作K8s

* K8s Python API Client: https://github.com/kubernetes-client/python/
* API接口示例: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#create-deployment-v1-apps

```yaml
$ curl -X POST -H 'Content-Type: application/yaml' --data '
apiVersion: apps/v1
kind: Deployment
metadata:
  name: deployment-example
spec:
  replicas: 3
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14
        ports:
        - containerPort: 80
' http://127.0.0.1:8001/apis/apps/v1/namespaces/default/deployments
```

* 持久化需求：
  1. 日志持久化：容器中日志通过filebeats收集到ELK中，ELK设置日志过期时间，项目组不需要关心日志收集细节。日志收集目录做好约定。
  2. 文件持久化：项目组可以在编写Dockerfile时自己决定哪些文件目录需要持久化，K8s集群中提供按照项目独立的PV。
* 访问集群上运行的服务：
  1. 开发环境仅可以从公司内网环境中访问，不暴露给公网。
  2. Web提供工具，可以通过kubectl exec连接到某个K8s集群容器中。https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-services/


### 任务处理过程

* 根据Web上用户的选择和设置，生成描述用户希望的环境说明：

```json
{
  "game": "JAP",
  "cluster_name": "Kouzan",
  "services": [
    {
      "module": "game",
      "repository": "",
      "docker_image": "game.20210422",
      "service_port": 10001 
    },
    {
      "module": "game",
      "repository": "",
      "docker_image": "game.20210422",
      "service_port": 10002,
    },
    {
      "module": "global",
      "repository": "",
      "docker_image": "global.20210422",
      "service_port": 20001,
    }
  ]
}
```

* 根据环境描述文件，生成可以供K8s API消息的Deployment文件。

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: JAP
spec:
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app: Kouzan
  template:
    metadata:
      labels:
        app: Kouzan
    spec:
      containers:
      - name: Kouzan-game-01
        image: game.20210422
        ports:
        - containerPort: 10001
      - name: Kouzan-game-02
        image: game.20210422
        ports:
        - containerPort: 10001
      - name: Kouzan-global-01
        image: global.20210422
        ports:
        - containerPort: 20001
```

* 引入消息队列有以下好处：
  * 限制同时发往K8s的请求数量，限制并发。
  * 更改集群的请求发送前可以做集群，命名空间容量评估。
  * 任务重试，失败任务回溯等。


### xxx

* 数值信息挂载
* 服务启动后在etcd注册完成，如何通知到web。
* 数据库
* protocol文件描述
* 
